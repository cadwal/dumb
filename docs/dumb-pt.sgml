<!DOCTYPE Book PUBLIC "-//OASIS//DTD DocBook V3.1//EN" [
  <!ENTITY pt-lang ".pt">

  <!ENTITY generated-index SYSTEM "dumb-pt-index.sgml">

  <!-- FIXME: Is this the right way of defining entities referred to
       by OLINK? -->

  <!NOTATION Texinfo
             -- PUBLIC "-//GNU//NOTATION Texinfo//EN" --
             SYSTEM>

  <!ENTITY doc-cpp
           -- PUBLIC "-//GNU//DOCUMENT The C Preprocessor//EN" --
           SYSTEM
           NDATA Texinfo>
  <!ENTITY doc-gettext
           -- PUBLIC "-//GNU//DOCUMENT GNU gettext utilities//EN" --
           SYSTEM
           NDATA Texinfo>
  <!ENTITY doc-glibc
           -- PUBLIC "-//GNU//DOCUMENT The GNU C Library Reference Manual//EN" --
           SYSTEM
           NDATA Texinfo>
]>

<!-- Formal public identifier of this document:
     "-//Kalle Niemitalo//DOCUMENT DUMB The .pt Language//EN" -->

<!-- Uses of some elements and attributes:

     <database role="level">E1M1</database>
     <database role="lumpname">HUNDRED%</database>
     <literal lang=".pt" role="clause">TimeUnits 2ms</literal>
     <literal lang=".pt">"HUNDRED%%"</literal>
     <literal lang="C" role="directive">#include &lt;dumb/dumbdefs.pt&gt;</literal>
     <token lang=".pt" role="constant">180deg</token>
     <token lang=".pt" role="directive">#include</token>
     <token lang=".pt" role="keyword">Gets</token>
     <token lang=".pt" role="macro">GETT_SPC_SUPERSIGHT</token>
     <token lang=".pt" role="macro">N_</token>
     <token lang=".pt">\\</token>
     <token lang="C">//</token>

     Also, every INDEXTERM has an ID, and a ROLE of either "concept"
     or "keyword".

-->

<book lang="en">
 <bookinfo>
  <title>The &pt-lang; Language</title>
  <address>
   <firstname>Kalle</firstname>
   <surname>Niemitalo</surname>
   <street>Takkurannantie 36</street>
   <postcode>90820 Kello</postcode>
   <country>Finland</country>
   <email>tosi@stekt.oulu.fi</email>
  </address>
  <copyright>
   <year>1999</year>
   <holder>Kalle Niemitalo</holder>
  </copyright>
  <legalnotice>
   <simpara>For now, this manual is under the
    <ulink url="http://www.gnu.org/copyleft/gpl.html"><acronym>GNU</acronym>
     General Public License</ulink>, version 2 or later.  I'll
    probably place later versions under a looser license which
    allows distributing printed copies without source code, but I
    don't want to think about that yet.</simpara>
  </legalnotice>
  <productname>DUMB</productname>
 </bookinfo>
 <part id="part-intro">
  <title>Introduction</title>
  <chapter id="sect-invoking-ptcomp">
   <title>Invoking <command>ptcomp</command></title>
   <simpara><command>ptcomp</command> compiles &pt-lang; scripts to
    the binary format used by <application>DUMB</application>.  It
    creates several lumps: one for Gettables, one for ProtoThings, one
    for Sounds, one for each Font, etc.  It can save all the lumps in
    one big WAD file, but it can also save each lump in a separate
    file.  You must use either
    <option>--output-directory=<replaceable>directory</replaceable></option>
    or <option>--output-wad=<replaceable>wadfile</replaceable></option> to
    choose what it does.</simpara> 
   <simpara>A &pt-lang; script usually contains C preprocessor
    directives like <literal lang="C" role="directive">#include
     &lt;dumb/dumbdefs.pt&gt;</literal>. <command>ptcomp</command>
    does not understand those directives, so the script must be run
    via the C preprocessor before giving it to
    <command>ptcomp</command>.  Do something like this:</simpara>
   <informalexample>
<programlisting>
<command>/lib/cpp</command> <filename><replaceable>input</replaceable>.pt</filename> | <command>ptcomp</command> <option>-o <filename><replaceable>output</replaceable>.wad</filename></option>
</programlisting>
   </informalexample>
   <simpara>Since not all C preprocessors understand C++-style
    <token lang="C">//</token> comments, you shouldn't use them in
    &pt-lang; scripts.</simpara>
   <variablelist>
    <title>Options understood by <command>ptcomp</command></title>
    <varlistentry>
     <term><option>--output-wad=<replaceable>wadfile</replaceable></option></term>
     <term><option>-o <replaceable>wadfile</replaceable></option></term>
     <listitem>
      <simpara>Create a WAD file called
       <replaceable>wadfile</replaceable> and write the lumps in it.
       This is now the recommended way of using
       <command>ptcomp</command>.</simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><option>--output-directory=<replaceable>directory</replaceable></option></term>
     <term><option>-d <replaceable>directory</replaceable></option></term>
     <listitem>
      <simpara>Write each lump in a separate file in
       <replaceable>directory</replaceable>.
       All the filenames will end in <literal>.lump</literal>.
       You can use the <command>wadtool</command> utility to combine
       the lumps into a WAD later, perhaps with others.</simpara>
      <simpara>This mode is retained for compatibility.
       It is no longer recommended, since you'll have
       to change your compilation scripts if a future version of
       <application>DUMB</application> adds more lumps.</simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><option>--fake-strings</option></term>
     <listitem>
      <simpara>If <command>ptcomp</command> sees a name token when it
       expects a string, it normally aborts compilation.  But if
       <option>--fake-strings</option> is given, it instead quietly
       translates names to strings where needed.</simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><option>--help</option></term>
     <listitem>
      <simpara>Print a usage message listing all available options,
       then exit successfully.</simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term><option>--version</option></term>
     <listitem>
      <simpara>Print the version number, then exit
       successfully.</simpara>
     </listitem>
    </varlistentry>
   </variablelist>
  </chapter>
  <chapter id="sect-syntax">
   <title>Syntax of &pt-lang; scripts</title>
   <simpara>Scripts are usually fed through the C preprocessor before
    giving them to <command>ptcomp</command>.  Thus C comments and
    preprocessor directives can be used.</simpara>
   <simpara>After preprocessing, scripts consist of tokens separated
    by tabs and spaces.  The number of spaces doesn't
    matter.</simpara>
   <sect1 id="sect-tokens">
    <title>What the scripts are made of</title>
    <simpara>There are three major kinds of tokens:</simpara>
    <variablelist>
     <varlistentry>
      <term>Newline</term>
      <listitem>
       <simpara>Newlines may appear between clauses but not inside
	them.</simpara>
      </listitem>
     </varlistentry>
     <varlistentry>
      <indexterm id="concept-string" role="concept">
       <primary>string</primary>
      </indexterm>
      <term>String</term>
      <listitem>
       <simpara>If the token begins with a double quote
	(<token>"</token>), it is a string.  The string can contain
	spaces and doesn't end until a closing quote is
	found.</simpara>
       <simpara>The C-style backslash escapes
	<token lang=".pt">\"</token>,
	<token lang=".pt">\'</token> and
	<token lang=".pt">\\</token> can be used to embed quotes
	and backslashes in the string.  Other sequences like
	<token lang="C">\a</token> and
	<token lang="C">\x1B</token> have not been implemented;
	<command>ptcomp</command> gives an error message if it sees
	those.</simpara>
       <simpara>Strings seen by players should be wrapped in the
	<link linkend="sect-n"><token lang=".pt" role="macro">N_</token>
	 macro</link>.</simpara>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Other</term>
      <listitem>
       <simpara>If the token isn't a newline or a string, it ends at
	the next whitespace character (which may itself be a new
	token, if it is a newline).  Numbers, names and keywords
	fall in this class.  The recognition of keywords is
	context-sensitive: <wordasword>Proto</wordasword> is
	interpreted as a keyword if it begins a declaration, but if it
	follows a keyword which expects a name, it is taken as a
	name.</simpara>
       <simpara>Keywords are case-insensitive.</simpara>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect1>
   <sect1 id="sect-n">
    <title>Marking strings for translation</title>
    <para>If a string is going to be shown to the player, it should be
     wrapped in the <token lang=".pt" role="macro">N_</token>
     macro, like this:
     <informalexample>
<programlisting>
PickupMessage N_("Picked up a stimpak.")
</programlisting>
     </informalexample>
    </para>
    <simpara>The macro is defined in
     <filename><indexterm id="concept-1-dumb-dumbdefs-pt" role="concept">
       <primary>&lt;dumb/dumbdefs.pt&gt;</primary>
      </indexterm>&lt;dumb/dumbdefs.pt&gt;</filename> which your
     &pt-lang; script should
     <token lang=".pt" role="directive">#include</token>.</simpara>
    <simpara>The purpose of <token lang=".pt" role="macro">N_</token>
     is to mark the string for translation, so that people around the
     world can get the messages in their own languages.
     <application>DUMB</application> is not smart enough to
     automatically translate messages to the languages of the world,
     but it can use the
     <olink targetdocent="doc-gettext"
	    localinfo="gettext"><acronym>GNU</acronym>
      <application>gettext</application> library</olink> to look up
     the translations from a file if someone first collects them
     there.  The
     <olink targetdocent="doc-gettext"
	    localinfo="xgettext Invocation"><command>xgettext</command></olink>
     program can be made to scan files for strings wrapped in
     <token lang=".pt" role="macro">N_</token>
     macros and present the list to the person translating them to
     another language.</simpara>
    <simpara>The message catalog used for translations is selected
     with the
     <link linkend="sect-messagedomain"
	   ><token lang=".pt" role="keyword">MessageDomain</token>
      clause</link>.</simpara>
    <simpara>Do not use
     <token lang=".pt" role="macro">N_</token>
     on sprite names or other such things the player will never
     see.</simpara>
   </sect1>
  </chapter>
  <chapter id="sect-conventions">
   <title>How to read this manual</title>
   <simpara>FIXME: some blurb</simpara>
   <sect1 id="sect-sample-clause">
    <title>Sample clause</title>
    <simpara>Here's one example of how the syntax of &pt-lang; clauses
     is shown in this manual:</simpara>
<synopsis>
Gets <replaceable>gettable</replaceable> <replaceable>howmany:integer</replaceable> <optional>Maximum <replaceable>max:integer</replaceable></optional>
</synopsis>
    <simpara><indexterm id="concept-clause" role="concept">
      <primary>clause</primary>
     </indexterm>This clause begins with the
     <token lang=".pt" role="keyword">Gets</token>
     keyword.  The keyword must be followed by two parameters:
     <replaceable>gettable</replaceable> which is the name of some
     Gettable, and <replaceable>howmany</replaceable> which is an
     integer.  In these syntax descriptions, the colon
     (<wordasword>:</wordasword>) separates the names of parameters
     from their types.  The type of
     <replaceable>gettable</replaceable> is omitted, since it should
     be obvious from the name.</simpara>
    <simpara>After <replaceable>howmany</replaceable>, there may be a
     <token lang=".pt" role="keyword">Maximum</token>
     keyword followed by the
     <replaceable>max</replaceable> parameter which is an
     integer.</simpara>
    <simpara>Colons and square brackets are not used in real &pt-lang;
     scripts, except perhaps in strings.</simpara>
   </sect1>
   <sect1 id="sect-arc">
    <indexterm id="concept-arc-units" role="concept">
     <primary>arc units</primary>
    </indexterm>
    <title>Arc parameter syntax</title>
    <simpara>Arcs are quantities like
     <token lang=".pt" role="constant">180deg</token> or
     <token lang=".pt" role="constant">2pi</token>.
     When a keyword expects an arc parameter,
     you can form it in any of the following ways:</simpara>
    <variablelist>
     <varlistentry>
      <term><replaceable>integer</replaceable>deg</term>
      <listitem>
       <simpara><token lang=".pt" role="constant">360deg</token>
	is a full circle;
	<token lang=".pt" role="constant">180deg</token>
	is half of it.</simpara>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><optional><replaceable>integer</replaceable></optional>pi</term>
      <listitem>
       <simpara><token lang=".pt" role="constant">2pi</token>
	 is a full circle;
	<token lang=".pt" role="constant">1pi</token> or
	<token lang=".pt" role="constant">pi</token>
	is half of it.</simpara>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><optional><replaceable>integer</replaceable></optional>pi/<replaceable>divisor</replaceable></term>
      <listitem>
       <simpara>As above but divided with
	<replaceable>divisor</replaceable> which must also be an
	integer.  So,
	<token lang=".pt" role="constant">pi/5</token> or
	<token lang=".pt" role="constant">2pi/10</token>
	would be the same as
	<token lang=".pt" role="constant">36deg</token>.</simpara>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><token lang=".pt" role="constant"><replaceable>integer</replaceable></token></term>
      <listitem>
       <simpara>This is an obsolete syntax which should not be used
	any more.  It means
	<token lang=".pt" role="constant">0deg</token> if
	<replaceable>integer</replaceable> is 0, or
	<token lang=".pt" role="constant">pi/<replaceable>integer</replaceable></token>
	otherwise.</simpara>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect1>
   <sect1 id="sect-time">
    <indexterm id="concept-time-units" role="concept">
     <primary>time units</primary>
    </indexterm>
    <title>Time parameter syntax</title>
    <simpara>When a keyword needs a time as a parameter, use one of
     the following syntaxes:</simpara>
    <variablelist>
     <varlistentry>
      <term><token lang=".pt" role="constant"><replaceable>integer</replaceable>sec</token></term>
      <listitem>
       <simpara><replaceable>integer</replaceable> seconds.</simpara>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><token lang=".pt" role="constant"><replaceable>integer</replaceable>msec</token></term>
      <listitem>
       <simpara><replaceable>integer</replaceable> milliseconds
	(1/1000).  The game doesn't really have millisecond accuracy
	but you can pretend it has.</simpara>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><token lang=".pt" role="constant"><replaceable>integer</replaceable>ticks</token></term>
      <listitem>
       <simpara><replaceable>integer</replaceable> timer ticks. As of
	<application>DUMB</application> 0.13.7, there are 100 ticks
	per second.</simpara>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><token lang=".pt" role="constant"><replaceable>integer</replaceable></token></term>
      <listitem>
       <simpara>If the time unit isn't given, the default unit is
	used.  It defaults to ticks but can be changed with the
	<link linkend="sect-units"
	      ><token lang=".pt" role="keyword">TimeUnits</token>
	 clause</link>.</simpara>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect1>
  </chapter>
 </part>
 <part id="part-reference">
  <title>Reference</title>
  <chapter id="sect-top-level">
   <title>Top-level clauses</title>
   <simpara>These clauses are written in the top level, outside any
    definitions.</simpara>
   <sect1 id="sect-units">
    <title>Changing default units</title>
    <variablelist>
     <varlistentry>
      <term>
       <indexterm id="keyword-timeunits" role="keyword">
	<primary>TimeUnits</primary>
       </indexterm>
<synopsis>
TimeUnits <replaceable>time</replaceable>
</synopsis>
      </term>
      <listitem>
       <simpara>The <token lang=".pt" role="keyword">TimeUnits</token>
	clause changes the default time unit for the rest of the
	script.  If you don't change the default time unit, it is
	<token lang=".pt" role="constant">1ticks</token>.</simpara>
       <simpara><replaceable>time</replaceable> can contain both a
	number and a unit.  For example, after
	<literal lang=".pt" role="clause">TimeUnits 2ms</literal>,
	the time value <token lang=".pt" role="constant">10</token>
	would mean
	<token lang=".pt" role="constant">20ms</token>.</simpara>
       <simpara>For a list of time units, see
	<xref linkend="sect-time">.</simpara>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>
       <indexterm id="keyword-speedunits" role="keyword">
	<primary>SpeedUnits</primary>
       </indexterm>
<synopsis>
SpeedUnits <replaceable>speed</replaceable>
</synopsis>
      </term>
      <listitem>
       <simpara><token lang=".pt" role="keyword">SpeedUnits</token>
	works like <token lang=".pt" role="keyword">TimeUnits</token>
	but changes the default speed unit.  The initial value is
	1/4096 of <token lang=".pt" role="constant">1/tick</token>.
	There is currently no way to express such tiny values in
	<token lang=".pt" role="keyword">SpeedUnits</token>;
	this is likely to change.</simpara>
      </listitem>
     </varlistentry>
    </variablelist>
    <simpara><token lang=".pt" role="keyword">TimeUnits</token> and
     <token lang=".pt" role="keyword">SpeedUnits</token> are not saved
     in the WAD file; they only set values which
     <command>ptcomp</command> uses for interpreting other clauses.
     They can be given several times, and each setting lasts until it
     is overridden.</simpara>
   </sect1>
   <sect1 id="sect-messagedomain">
    <title>Message translation domain</title>
    <simpara>Each WAD file contains messages in one language only.
     The translations to other languages are kept in separate
     <filename>.mo</filename> files; for example, the Finnish
     translation of <filename>doom4dum.wad</filename> could be in
     <filename>/usr/local/share/local/fi/LC_MESSAGES/dumb-utf8.mo</filename>.
     The <literal>dumb-utf8</literal> part is called the domain.
     Translations of different games can be kept in separate files by
     choosing a separate domain for each game.</simpara>
    <variablelist>
     <varlistentry>
      <term>
       <indexterm id="keyword-messagedomain" role="keyword">
	<primary>MessageDomain</primary>
       </indexterm>
<synopsis>
MessageDomain <replaceable>domain:string</replaceable>
</synopsis>
      </term>
      <listitem>
       <simpara><token lang=".pt" role="keyword">MessageDomain</token>
	marks <replaceable>domain</replaceable> as the domain from
	which <application>DUMB</application> will read the
	translations of all WAD messages.  The translations need not
	be available during compilation; only the name of the domain
	is saved.</simpara>
       <simpara>There can be only one
	<token lang=".pt" role="keyword">MessageDomain</token>
	clause in each compilation.</simpara>
      </listitem>
     </varlistentry>
    </variablelist>
    <simpara>Currently, <application>DUMB</application> uses the same
     message domain for all WAD files of the game.  Assume
     <filename>rocketland.wad</filename> specifies
     <literal lang=".pt" role="clause">MessageDomain "rocketland"</literal>
     and <filename>nuke.wad</filename> specifies
     <literal lang=".pt" role="clause">MessageDomain "nuke"</literal>.
     Then if you start DUMB with both
     <filename>rocketland.wad</filename> and
     <filename>nuke.wad</filename>, translations for messages of
     <emphasis>both</emphasis> WADs are looked for in the
     <wordasword>nuke</wordasword> domain.  This could be thought of
     as a bug.</simpara>
   </sect1>
  </chapter>
  <chapter id="sect-gettable">
   <title>Defining Gettables</title>
   <simpara>Gettables are objects carried by players, such as weapons,
    ammunition and inventory items.  The player usually gets them by
    collecting a Thing from the level
    (see <xref linkend="sect-powerups">),
    but you can also make the player have some Gettables right from
    the beginning of the game.</simpara>
   <simpara>Temporary special powers like invisibility are also
    implemented as Gettables.  So are health and armour.</simpara>
   <indexterm id="keyword-gettable" role="keyword">
    <primary>Gettable</primary>
   </indexterm>
<synopsis>
Gettable <replaceable>gettable</replaceable>
</synopsis>
   <simpara>This clause begins the definition of a Gettable called
    <replaceable>gettable</replaceable>.  To specify the details of
    the new Gettable, follow it with the other clauses defined in the
    following sections.</simpara>
   <sect1 id="sect-amounts" xreflabel="Amounts of Gettables">
    <title>Amounts of Gettables</title>
    <simpara>The following clauses can only be used inside a
     <token lang=".pt" role="keyword">Gettable</token>
     definition:</simpara>
    <variablelist>
     <varlistentry>
      <term>
       <indexterm id="keyword-initial" role="keyword">
	<primary>Initial</primary>
       </indexterm>
<synopsis>
Initial <replaceable>initial:integer</replaceable>
</synopsis>
      </term>
      <term>
       <indexterm id="keyword-onemaponly" role="keyword">
	<primary>OneMapOnly</primary>
       </indexterm>
<synopsis>
OneMapOnly
</synopsis>
      </term>
      <listitem>
       <simpara>When the game begins, each player gets
	<replaceable>initial</replaceable> units of this Gettable.
	Defaults to 0 if not given.</simpara>
       <simpara>If the Gettable is defined as
	<token lang=".pt" role="keyword">OneMapOnly</token>,
	the value is reset to
	<replaceable>initial</replaceable> at the beginning of each
	map.</simpara>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>
       <indexterm id="keyword-defaultmaximum" role="keyword">
	<primary>DefaultMaximum</primary>
       </indexterm>
       <indexterm id="keyword-withbackpack" role="keyword">
	<primary>WithBackpack</primary>
       </indexterm>
<synopsis>
DefaultMaximum <replaceable>max:integer</replaceable> <optional>WithBackpack <replaceable>maxwithpack:integer</replaceable></optional>
</synopsis>
      </term>
      <listitem>
       <simpara>When this Gettable is got via a
	<link linkend="sect-gets"><token lang=".pt" role="keyword">Gets</token>
	 clause</link> in a
	<token lang=".pt" role="keyword">Proto</token>
	definition, the maximum possible amount defaults to
	<replaceable>max</replaceable> if not overridden in the
	<token lang=".pt" role="keyword">Gets</token> clause.</simpara>
       <simpara>However, if the player has a backpack,
	<replaceable>maxwithpack</replaceable> is used instead. For
	information on how to define a Gettable as the backpack, see
	<xref linkend="sect-special">.</simpara>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect1>
   <sect1 id="sect-icon">
    <title>Icon of Gettable</title>
    <simpara>FIXME: describe what the icons are, also
     <option>--dumb-uncrowd</option></simpara>
    <variablelist>
     <varlistentry>
      <term>
       <indexterm id="keyword-icon" role="keyword">
	<primary>Icon</primary>
       </indexterm>
<synopsis>
Icon <replaceable>icon:string9</replaceable>
</synopsis>
      </term>
      <listitem>
       <simpara>FIXME: document</simpara>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>
       <indexterm id="keyword-iconpos" role="keyword">
	<primary>IconPos</primary>
       </indexterm>
<synopsis>
IconPos <replaceable>xo:integer</replaceable> <replaceable>yo:integer</replaceable>
</synopsis>
      </term>
      <term>
       <indexterm id="keyword-xcenter" role="keyword">
	<primary>XCenter</primary>
       </indexterm>
<synopsis>
XCenter
</synopsis>
      </term>
      <term>
       <indexterm id="keyword-ycenter" role="keyword">
	<primary>YCenter</primary>
       </indexterm>
<synopsis>
YCenter
</synopsis>
      </term>
      <listitem>
       <simpara>FIXME: document</simpara>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>
       <indexterm id="keyword-anim" role="keyword">
	<primary>Anim</primary>
       </indexterm>
<synopsis>
Anim <replaceable>char</replaceable>
</synopsis>
      </term>
      <term>
       <indexterm id="keyword-revanim" role="keyword">
	<primary>RevAnim</primary>
       </indexterm>
<synopsis>
RevAnim <replaceable>char</replaceable>
</synopsis>
      </term>
      <listitem>
       <simpara>FIXME: document</simpara>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>
       <indexterm id="keyword-timing" role="keyword">
	<primary>Timing</primary>
       </indexterm>
<synopsis>
Timing <replaceable>time</replaceable>
</synopsis>
      </term>
      <listitem>
       <simpara>FIXME: document</simpara>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect1>
   <sect1 id="sect-items">
    <title>Weapons and inventory items</title>
    <indexterm id="concept-weapon" role="concept">
     <primary>weapon</primary>
    </indexterm>
    <indexterm id="concept-inventory" role="concept">
     <primary>inventory</primary>
    </indexterm>
    <simpara>FIXME: explain why to use these, and what key bindings
     apply</simpara>
    <variablelist>
     <varlistentry>
      <term>
       <indexterm id="keyword-wepsel" role="keyword">
	<primary>WepSel</primary>
       </indexterm>
<synopsis>
WepSel
</synopsis>
      </term>
      <term>
       <indexterm id="keyword-spesel" role="keyword">
	<primary>SpeSel</primary>
       </indexterm>
<synopsis>
SpeSel
</synopsis>
      </term>
      <listitem>
       <simpara>FIXME: document</simpara>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>
       <indexterm id="keyword-bogotype" role="keyword">
	<primary>Bogotype</primary>
       </indexterm>
<synopsis>
Bogotype <replaceable>bogo:proto</replaceable>
</synopsis>
      </term>
      <term>
       <indexterm id="keyword-poweredbogotype" role="keyword">
	<primary>PoweredBogotype</primary>
       </indexterm>
<synopsis>
PoweredBogotype <replaceable>powered_bogo:proto</replaceable>
</synopsis>
      </term>
      <listitem>
       <simpara>FIXME: document</simpara>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>
       <indexterm id="keyword-ammo" role="keyword">
	<primary>Ammo</primary>
       </indexterm>
<synopsis>
Ammo <replaceable>ammo:gettable</replaceable> <replaceable>count:integer</replaceable>
</synopsis>
      </term>
      <listitem>
       <simpara>When this Gettable is used as a weapon or item, use up
	<replaceable>count</replaceable> units of
	<replaceable>ammo</replaceable>.  If there is not enough ammo,
	the weapon cannot be used.</simpara>
       <simpara>By default, weapons don't need ammo.</simpara>
       <simpara>To make an item which can only be used once, set
	<replaceable>count</replaceable> to 1 and
	<replaceable>ammo</replaceable> to the Gettable
	itself.</simpara>
       <simpara>If there are several
	<token lang=".pt" role="keyword">Ammo</token> clauses in a
        <token lang=".pt" role="keyword">Gettable</token>, then the
       Gettable needs all the ammo types listed.</simpara>
       <simpara>This clause has no effect to what kind of missiles the
	weapon sends.  That is defined by the
	<token lang=".pt" role="keyword">Spawns</token>
	clause in the weapon's bogothing.
	<comment>FIXME: add a link when Spawns has been
	 documented.</comment></simpara>
      </listitem>
     </varlistentry>
    </variablelist>
    <simpara>To make an item which gives the player other Gettables
     when it is used, write a
     <link linkend="sect-gets"><token lang=".pt" role="keyword">Gets</token>
      clause</link> in the
     <token lang=".pt" role="keyword">Gettable</token>.
     <literal lang=".pt" role="clause">Ammo
      <replaceable>ammo</replaceable>
      <replaceable>count</replaceable></literal>
     is actually equivalent to
     <literal lang=".pt" role="clause">Gets
      <replaceable>ammo</replaceable>
      -<replaceable>count</replaceable></literal>.</simpara>
   </sect1>
   <sect1 id="sect-special">
    <title>Special features as Gettables</title>
    <simpara>In addition to weapons and other tangible items,
     Gettables can also represent other properties of the player, like
     health and armour.  This way, the same mechanism which gives the
     player bullets when he picks up a clip, can be used to increase
     his health when he picks up a health bonus.</simpara>
    <variablelist>
     <varlistentry>
      <term>
       <indexterm id="keyword-special" role="keyword">
	<primary>Special</primary>
       </indexterm>
<synopsis>
Special <replaceable>code:enum</replaceable>
</synopsis>
      </term>
      <listitem>
       <simpara>This clause marks the Gettable as denoting one special
	feature.</simpara>
       <simpara><replaceable>code</replaceable> must be one of the
	following constants, defined in
	<filename>&lt;dumb/dumbdefs.pt&gt;</filename>:</simpara>
       <variablelist>
	<varlistentry>
	 <indexterm id="concept-health" role="concept">
	  <primary>health</primary>
	 </indexterm>
	 <term>
	  <indexterm id="keyword-gett-spc-health" role="keyword">
	   <primary>GETT_SPC_HEALTH</primary>
	  </indexterm>
	  <token lang=".pt" role="macro">GETT_SPC_HEALTH</token>
	 </term>
	 <listitem>
	  <simpara>This marks the Gettable as the player's health.
	   When the player gets damage, it's taken from the health.
	   If health goes to 0, the player dies.</simpara>
	 </listitem>
	</varlistentry>
	<varlistentry>
	 <indexterm id="concept-armour" role="concept">
	  <primary>armour</primary>
	 </indexterm>
	 <term>
	  <indexterm id="keyword-gett-spc-armour" role="keyword">
	   <primary>GETT_SPC_ARMOUR</primary>
	  </indexterm>
	  <token lang=".pt" role="macro">GETT_SPC_ARMOUR</token>
	 </term>
	 <listitem>
	  <simpara>This marks the Gettable as the player's armour.
	   When the player has armour, half of the damage he gets is
	   taken from it.</simpara>
	 </listitem>
	</varlistentry>
	<varlistentry>
	 <indexterm id="concept-invisibility" role="concept">
	  <primary>invisibility</primary>
	 </indexterm>
	 <term>
	  <indexterm id="keyword-gett-spc-invisibility" role="keyword">
	   <primary>GETT_SPC_INVISIBILITY</primary>
	  </indexterm>
	  <token lang=".pt" role="macro">GETT_SPC_INVISIBILITY</token>
	 </term>
	 <listitem>
	  <simpara>If the player has this Gettable, he is invisible.</simpara>
	 </listitem>
	</varlistentry>
	<varlistentry>
	 <indexterm id="concept-damage-protection" role="concept">
	  <primary>damage protection</primary>
	 </indexterm>
	 <indexterm id="concept-invulnerability" role="concept">
	  <primary>invulnerability</primary>
	 </indexterm>
	 <indexterm id="concept-god-mode" role="concept">
	  <primary>god mode</primary>
	 </indexterm>
	 <term>
	  <indexterm id="keyword-gett-spc-damageprotection" role="keyword">
	   <primary>GETT_SPC_DAMAGEPROTECTION</primary>
	  </indexterm>
	  <token lang=".pt" role="macro">GETT_SPC_DAMAGEPROTECTION</token>
	 </term>
	 <listitem>
	  <simpara>If the player has this Gettable, he can't be hurt
	   at all.</simpara>
	 </listitem>
	</varlistentry>
	<varlistentry>
	 <indexterm id="concept-slime-protection" role="concept">
	  <primary>slime protection</primary>
	 </indexterm>
	 <indexterm id="concept-radiation-suit" role="concept">
	  <primary>radiation suit</primary>
	 </indexterm>
	 <term>
	  <indexterm id="keyword-gett-spc-slimeprotection" role="keyword">
	   <primary>GETT_SPC_SLIMEPROTECTION</primary>
	  </indexterm>
	  <token lang=".pt" role="macro">GETT_SPC_SLIMEPROTECTION</token>
	 </term>
	 <listitem>
	  <simpara>If the player has this Gettable, the icky goo on
	   the floor doesn't hurt him.</simpara>
	 </listitem>
	</varlistentry>
	<varlistentry>
	 <indexterm id="concept-night-vision" role="concept">
	  <primary>night vision</primary>
	 </indexterm>
	 <indexterm id="concept-goggles" role="concept">
	  <primary>goggles</primary>
	 </indexterm>
	 <indexterm id="concept-light-amplification-visor" role="concept">
	  <primary>light amplification visor</primary>
	 </indexterm>
	 <term>
	  <indexterm id="keyword-gett-spc-supersight" role="keyword">
	   <primary>GETT_SPC_SUPERSIGHT</primary>
	  </indexterm>
	  <token lang=".pt" role="macro">GETT_SPC_SUPERSIGHT</token>
	 </term>
	 <listitem>
	  <simpara>If the player has this Gettable, he sees in the
	   dark.</simpara>
	 </listitem>
	</varlistentry>
	<varlistentry>
	 <indexterm id="concept-backpack" role="concept">
	  <primary>backpack</primary>
	 </indexterm>
	 <term>
	  <indexterm id="keyword-gett-spc-backpack" role="keyword">
	   <primary>GETT_SPC_BACKPACK</primary>
	  </indexterm>
	  <token lang=".pt" role="macro">GETT_SPC_BACKPACK</token>
	 </term>
	 <listitem>
	  <simpara>When the player collects items,
	   <application>DUMB</application> checks whether he has the
	   backpack.  If so, a different maximum may be used.  See
	   <xref linkend="sect-amounts">.</simpara>
	 </listitem>
	</varlistentry>
	<varlistentry>
	 <indexterm id="concept-computer-area-map" role="concept">
	  <primary>computer area map</primary>
	 </indexterm>
	 <indexterm id="concept-map-automatic" role="concept">
	  <primary>map</primary>
	  <secondary>automatic</secondary>
	 </indexterm>
	 <term>
	  <indexterm id="keyword-gett-spc-allmap" role="keyword">
	   <primary>GETT_SPC_ALLMAP</primary>
	  </indexterm>
	  <token lang=".pt" role="macro">GETT_SPC_ALLMAP</token>
	 </term>
	 <listitem>
	  <simpara>When the player has this Gettable, the map shows
	   him even the places he hasn't visited yet.</simpara>
	 </listitem>
	</varlistentry>
	<varlistentry>
	 <indexterm id="concept-tome-of-power" role="concept">
	  <primary>tome of power</primary>
	 </indexterm>
	 <term>
	  <indexterm id="keyword-gett-spc-powerweapons" role="keyword">
	   <primary>GETT_SPC_POWERWEAPONS</primary>
	  </indexterm>
	  <token lang=".pt" role="macro">GETT_SPC_POWERWEAPONS</token>
	 </term>
	 <listitem>
	  <simpara>When the player has this Gettable, his weapons use
	  their <token lang=".pt" role="keyword">PoweredBogotype</token>.</simpara>
	 </listitem>
	</varlistentry>
	<varlistentry>
	 <indexterm id="concept-wings-of-wrath" role="concept">
	  <primary>wings of wrath</primary>
	 </indexterm>
	 <term>
	  <indexterm id="keyword-gett-spc-wings" role="keyword">
	   <primary>GETT_SPC_WINGS</primary>
	  </indexterm>
	  <token lang=".pt" role="macro">GETT_SPC_WINGS</token>
	 </term>
	 <listitem>
	  <simpara>When the player has this Gettable, he can fly.</simpara>
	 </listitem>
	</varlistentry>
       </variablelist>
      </listitem>
     </varlistentry>
    </variablelist>
    <simpara>It is not possible to use the same special number in two
     Gettables, but you can define several powerups which give
     different amounts of the same Gettable to the player.  See
     <xref linkend="sect-gets">.</simpara>
   </sect1>
  </chapter>
  <chapter id="sect-proto">
   <title>Defining ProtoThings</title>
   <variablelist>
    <varlistentry>
     <term>
      <indexterm id="keyword-proto" role="keyword">
       <primary>Proto</primary>
      </indexterm>
<synopsis>
Proto <replaceable>proto</replaceable> <optional><replaceable>id:integer</replaceable></optional>
</synopsis>
     </term>
     <listitem>
      <simpara>FIXME: document</simpara>
     </listitem>
    </varlistentry>
   </variablelist>
   <sect1 id="sect-powerups">
    <title>Powerups</title>
    <simpara>Powerups are Things which award the player one or more
     <link linkend="sect-gettable">Gettables</link>.</simpara>
    <simpara>You turn a Thing to a powerup by adding one or more
     <token lang=".pt" role="keyword">Gets</token> clauses in the ProtoThing defining that
     Thing.  They take effect when a player collides with the Thing.
     Until then, the powerup may even behave like a monster if you
     define it as one.</simpara>
    <simpara>You can also define a sound and messages which are
     emitted when the powerup is collected.</simpara>
    <sect2 id="sect-gets" xreflabel="Gettables from a powerup">
     <title>Gettables from a powerup</title>
     <variablelist>
      <varlistentry>
       <term>
	<indexterm id="keyword-gets" role="keyword">
	 <primary>Gets</primary>
	</indexterm>
	<indexterm id="keyword-maximum" role="keyword">
	 <primary>Maximum</primary>
	</indexterm>
<synopsis>
Gets <replaceable>gettable</replaceable> <replaceable>change:integer</replaceable> <optional>Maximum <replaceable>max:integer</replaceable></optional>
</synopsis>
       </term>
       <listitem>
	<simpara>Adding this clause in a
	 <token lang=".pt" role="keyword">Proto</token> definition
	 turns the Things it describes to powerups which the player
	 can pick up.  You can also write this clause in a <token
	 lang=".pt" role="keyword">Gettable</token>, in which case it
	 takes effect when the Gettable is used.</simpara>
	<simpara>If <replaceable>max</replaceable> isn't given, it
	 defaults to one of the values given in the
	 <token lang=".pt" role="keyword">DefaultMaximum</token>
	 clause of <replaceable>gettable</replaceable>.
	 Which value is used depends on whether the player has a
	 <link linkend="concept-backpack">backpack</link>.</simpara>
	<simpara>If the player already has
	 <replaceable>max</replaceable> or more units of
	 <replaceable>gettable</replaceable>, he doesn't pick the
	 Thing up.  The
	 <link linkend="keyword-ignoremessage"
	       ><token lang=".pt"
		       role="keyword">IgnoreMessage</token></link>
	 may be printed in this case.</simpara>
	<simpara>Otherwise, he gets <replaceable>change</replaceable>
	 units more.  Then, if he has more than
	 <replaceable>max</replaceable> units, the amount is clipped
	 to <replaceable>max</replaceable>.</simpara>
       </listitem>
      </varlistentry>
     </variablelist>
     <simpara>You can write multiple
      <token lang=".pt" role="keyword">Gets</token>
      clauses in one <token lang=".pt" role="keyword">Proto</token>
      or <token lang=".pt" role="keyword">Gettable</token>.
      When the player collects such a powerup, he gets all the
      Gettables listed.
      He will ignore the powerup only if none of the clauses would
      give him Gettables.</simpara>
     <simpara>When creating powerups which give the player a weapon
      and ammo for it, you should make them give the ammo first and
      the weapon last.  If the player gets the weapon before he has
      ammo for it, the weapon won't be automatically
      selected.</simpara>
     <simpara>Similarly, a powerup giving a backpack and other items
      should give the backpack first, so that the player can carry the
      other items.  Or set the maximum of the other items
      explicitly.</simpara>
    </sect2>
    <sect2 id="sect-pickupsound">
     <title>PickupSound</title>
     <variablelist>
      <varlistentry>
       <term>
	<indexterm id="keyword-pickupsound" role="keyword">
	 <primary>PickupSound</primary>
	</indexterm>
<synopsis>
PickupSound <replaceable>sound</replaceable>
</synopsis>
       </term>
       <listitem>
	<simpara>FIXME: document</simpara>
       </listitem>
      </varlistentry>
     </variablelist>
    </sect2>
    <sect2 id="sect-pickupmessage">
     <title>Powerup messages</title>
     <variablelist>
      <varlistentry>
       <term>
	<indexterm id="keyword-firstpickupmessage" role="keyword">
	 <primary>FirstPickupMessage</primary>
	</indexterm>
<synopsis>
FirstPickupMessage <replaceable>firstpickupmessage:string</replaceable>
</synopsis>
       </term>
       <term>
	<indexterm id="keyword-pickupmessage" role="keyword">
	 <primary>PickupMessage</primary>
	</indexterm>
<synopsis>
PickupMessage <replaceable>pickupmessage:string</replaceable>
</synopsis>
       </term>
       <listitem>
	<simpara>When a player succeeds in picking up the powerup,
	 <application>DUMB</application> shows either
	 <replaceable>firstpickupmessage</replaceable> or
	 <replaceable>pickupmessage</replaceable>.  If the player
	 didn't already have the Gettable which the ProtoThing gives
	 and <replaceable>firstpickupmessage</replaceable> is defined,
	 <application>DUMB</application> prints that; otherwise,
	 <application>DUMB</application> prints
	 <replaceable>pickupmessage</replaceable> if that is
	 defined.</simpara>
	<simpara>If the ProtoThing has multiple
	 <token lang=".pt" role="keyword">Gets</token>
	 clauses and thus gives many different Gettables, only the
	 first of them affects the choice of message.</simpara>
	<simpara><token lang=".pt" role="keyword">FirstPickupMessage</token>
	 may be useful with decaying Gettables like temporary
	 invisibility: <application>DUMB</application> can show
	 <replaceable>firstpickupmessage</replaceable> when the player
	 becomes invisible and
	 <replaceable>pickupmessage</replaceable> when he gets more
	 time for the invisibility.  Currently, there is no way to
	 specify a message to be shown when the Gettable has decayed
	 completely and the player becomes visible again; if such a
	 feature were added, it would belong in
	 <token lang=".pt" role="keyword">Gettable</token>, not
	 <token lang=".pt" role="keyword">Proto</token>.</simpara>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>
	<indexterm id="keyword-ignoremessage" role="keyword">
	 <primary>IgnoreMessage</primary>
	</indexterm>
<synopsis>
IgnoreMessage <replaceable>ignoremessage:string</replaceable>
</synopsis>
       </term>
       <listitem>
	<simpara>When a player attempts to pick up the powerup but
	 can't carry it, <application>DUMB</application> shows him the
	 <replaceable>ignoremessage</replaceable>.  If you don't
	 define that, no message is shown.</simpara>
       </listitem>
      </varlistentry>
     </variablelist>
     <simpara>The message strings should be wrapped in the
      <link linkend="sect-n"><token lang=".pt" role="macro">N_</token>
       macro.</link></simpara>
    </sect2>
   </sect1>
  </chapter>
  <chapter id="sect-level">
   <title>Defining Levels</title>
   <simpara><indexterm id="concept-episode" role="concept">
     <primary>episode</primary>
    </indexterm>
    <indexterm id="concept-level" role="concept">
     <primary>level</primary>
    </indexterm>
    <indexterm id="concept-map-meaning-a-level" role="concept">
     <primary>map</primary>
     <secondary>meaning a level</secondary>
    </indexterm>
    <indexterm id="concept-mission" role="concept">
     <primary>mission</primary>
    </indexterm>
    An episode usually consists of several levels (also known
    as maps or missions) which the player plays in sequence.  Each of
    those levels needs a separate
    <token lang=".pt" role="keyword">Level</token>
    clause in the &pt-lang; script.  This example is from
    <application>DUMB</application>'s
    <filename>doom/levels.pt</filename>:</simpara>
   <informalexample>
<programlisting>
Level "E1M1"  Music "D_E1M1"  Sky "SKY1"  StartGame
Level "E1M2"  Music "D_E1M2"  Sky "SKY1"
Level "E1M3"  Music "D_E1M3"  Sky "SKY1"  Secret "E1M9"
Level "E1M4"  Music "D_E1M4"  Sky "SKY1"
Level "E1M5"  Music "D_E1M5"  Sky "SKY1"
Level "E1M6"  Music "D_E1M6"  Sky "SKY1"
Level "E1M7"  Music "D_E1M7"  Sky "SKY1"
Level "E1M8"  Music "D_E1M8"  Sky "SKY1"  EndGame
Level "E1M9"  Music "D_E1M9"  Sky "SKY1"  Next "E1M4"
</programlisting>
   </informalexample>
   <simpara><indexterm id="keyword-startgame" role="keyword">
     <primary>StartGame</primary>
    </indexterm>
    <indexterm id="keyword-endgame" role="keyword">
     <primary>EndGame</primary>
    </indexterm>
    Since <database role="level">E1M1</database> has the
    <token lang=".pt" role="keyword">StartGame</token>
    flag, the game will start there.  When the player finishes
    <database role="level">E1M1</database>, he's taken to
    <database role="level">E1M2</database>, from there to
    <database role="level">E1M3</database> and so on.
    <database role="level">E1M8</database> is marked with
    <token lang=".pt" role="keyword">EndGame</token>,
    so the game ends when the player gets to the exit there.
    <database role="level">E1M9</database> is a secret
    level.</simpara>
   <sect1 id="sect-secret">
    <title>Secret levels</title>
    <simpara><indexterm id="concept-secret-exit" role="concept">
      <primary>secret exit</primary>
     </indexterm>
     A level can have a secret exit which breaks the usual sequence of
     levels and takes the player somewhere else.  The
     <token lang=".pt" role="keyword">Secret</token>
     clause defines where it leads:</simpara>
    <variablelist>
     <varlistentry>
      <term>
       <indexterm id="keyword-secret" role="keyword">
	<primary>Secret</primary>
       </indexterm>
<synopsis>
Secret <replaceable>secret:level</replaceable>
</synopsis>
      </term>
      <listitem>
       <simpara>When the player exits this level via the secret exit,
	take him to <replaceable>secret</replaceable>, not the usual
	next level.</simpara>
       <simpara>For example, <application>DUMB</application>'s
	<filename>doom/levels.pt</filename> contains these
	lines:</simpara>
       <informalexample>
<programlisting>
Level "E1M3"  Music "D_E1M3"  Sky "SKY1"  Secret "E1M9"
Level "E1M4"  Music "D_E1M4"  Sky "SKY1"
</programlisting>
       </informalexample>
       <simpara>If the player goes to the secret exit in
	<database role="level">E1M3</database>, he is taken to
	<database role="level">E1M9</database>.
	The normal exit would take him to
	<database role="level">E1M4</database>.</simpara>
       <simpara>If you don't use
	<token lang=".pt" role="keyword">Secret</token>,
	the secret exit behaves just like the normal exit.</simpara>
      </listitem>
     </varlistentry>
    </variablelist>
    <simpara>When the player finishes a secret level, he should be
     taken back to the normal sequence.  This could be done by making
     the secret level's exit another secret exit and using
    <token lang=".pt" role="keyword">Secret</token>
     to direct that to the correct level, but in
     <application>Doom</application> maps it is a normal exit.
     So we have the
     <token lang=".pt" role="keyword">Next</token>
     keyword for changing the destination of the normal
     exit:</simpara>
    <variablelist>
     <varlistentry>
      <term>
       <indexterm id="keyword-next" role="keyword">
	<primary>Next</primary>
       </indexterm>
<synopsis>
Next <replaceable>next:level</replaceable>
</synopsis>
      </term>
      <listitem>
       <simpara>When the player exits this level via the normal exit,
	take him to <replaceable>next</replaceable>, not the usual
	next level.</simpara>
       <simpara>Here is a piece of
	<filename>doom/levels.pt</filename>:</simpara>
       <informalexample>
<programlisting>
Level "E1M8"  Music "D_E1M8"  Sky "SKY1"  EndGame
Level "E1M9"  Music "D_E1M9"  Sky "SKY1"  Next "E1M4"

Level "E2M1"  Music "D_E2M1"  Sky "SKY2"  StartGame
Level "E2M2"  Music "D_E2M2"  Sky "SKY2"
</programlisting>
       </informalexample>
       <simpara>When the player exits
	<database role="level">E1M9</database>, he is taken to
	<database role="level">E1M4</database>.
	Without	<token lang=".pt" role="keyword">Next</token>,
	the default would have been
	<database role="level">E2M1</database>.</simpara>
       <simpara>If there were a secret exit in
	<database role="level">E1M9</database>,
	that too would take the player to
	<database role="level">E1M4</database>.
	This is because the secret exit's target defaults to that of
	the normal exit unless overridden with
	<token lang=".pt" role="keyword">Secret</token>.</simpara>
      </listitem>
     </varlistentry>
    </variablelist>
    <simpara>The use of
     <token lang=".pt" role="keyword">Secret</token> and
     <token lang=".pt" role="keyword">Next</token>
     isn't limited to secret levels; you could form more complex
     structures with them.
     You shouldn't make links back to levels the player has already
     been in, because the status of a level is lost when the player
     leaves it, and he would have to fight all the same monsters
     again.  But if you want to do this, you can.</simpara>
   </sect1>
  </chapter>
  <chapter id="sect-font">
   <title>Defining Fonts</title>
   <variablelist>
    <varlistentry>
     <term>
      <indexterm id="keyword-font" role="keyword">
       <primary>Font</primary>
      </indexterm>
<synopsis>
Font <replaceable>fontname:string8</replaceable>
</synopsis>
     </term>
     <listitem>
      <simpara><indexterm id="concept-1-glyph" role="concept">
	<primary>glyph</primary>
       </indexterm>
       This clause begins the definition of a font which will
       be saved in a lump called <replaceable>fontname</replaceable>.
       The character glyphs must be stored separately; the font will
       just map them to the Unicode character set and give some
       formatting information.</simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>
      <indexterm id="keyword-spacecharwidth" role="keyword">
       <primary>SpaceCharWidth</primary>
      </indexterm>
<synopsis>
SpaceCharWidth <replaceable>integer</replaceable>
</synopsis>
     </term>
     <listitem>
      <comment>FIXME: document</comment>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>
      <indexterm id="keyword-delimiters" role="keyword">
       <primary>Delimiters</primary>
      </indexterm>
<synopsis>
Delimiters <replaceable>after:string8</replaceable> <replaceable>before:string8</replaceable>
</synopsis>
     </term>
     <listitem>
      <simpara> If the
       <token lang=".pt" role="keyword">Delimiters</token>
       clause appears in a
       <token lang=".pt" role="keyword">Font</token> definition, that
       means the character glyphs are only looked for between lumps
       <replaceable>after</replaceable> and
       <replaceable>before</replaceable>.  This reduces the risk of
       name clashes.
       <indexterm id="concept-name-clash" role="concept">
	<primary>name clash</primary>
       </indexterm>
       If you are taking the glyphs from a preexisting WAD which has
       only one delimiter, use an empty string for the missing
       one.</simpara>
     </listitem>
    </varlistentry>
   </variablelist>
   <simpara>The following clauses refer to characters with numeric
    codes.  Please use the codes in the
    <ulink url="http://www.unicode.org/">Unicode standard</ulink>.
    16-bit hex values like
    <token lang=".pt" role="constant">0x0020</token>
    are the preferred notation, but full 32 bits are available should
    the need arise.</simpara>
   <variablelist>
    <varlistentry>
     <term>
      <indexterm id="keyword-codingrange" role="keyword">
       <primary>CodingRange</primary>
      </indexterm>
<synopsis>
CodingRange <replaceable>firstchar:integer</replaceable> <replaceable>lastchar:integer</replaceable> <replaceable>format:string</replaceable> <optional><replaceable>firstparam:integer</replaceable></optional>
</synopsis>
     </term>
     <listitem>
      <simpara><indexterm id="concept-2-glyph" role="concept">
	<primary>glyph</primary>
       </indexterm>
       Defines glyphs for the characters having codes between
       <replaceable>firstchar</replaceable> and
       <replaceable>lastchar</replaceable>, inclusive.</simpara>
      <simpara>In the simplest case, all the characters in the range
       use the glyph which is in the lump named by
       <replaceable>format</replaceable>.
       If the lump name contains a percent sign, write it as two
       percent signs: the lump
       <database role="lumpname">HUNDRED%</database>
       would be written as
       <literal lang=".pt">"HUNDRED%%"</literal>.
       You don't need <replaceable>firstparam</replaceable>.</simpara>
      <simpara>If the names of lumps have some kind of sequence
       (<literal>FONTA1</literal>,
       <literal>FONTA2</literal>,
       <literal>FONTA3</literal>, ...),
       you may be able to specify all of them at once by embedding a
       <indexterm id="concept-printf" role="concept">
	<primary>printf</primary>
       </indexterm>
       <function>printf</function>-style
       <indexterm id="concept-conversion-specification" role="concept">
	<primary>conversion specification</primary>
       </indexterm>
       conversion specification in
       <replaceable>format</replaceable>, as in
       <literal lang=".pt">"FONTA%d"</literal>.
       (See 
       <olink targetdocent="doc-glibc" localinfo="Integer
	      Conversions"><citetitle pubwork="section">Integer
	 Conversions</citetitle> in
	<citetitle pubwork="book">The GNU C Library Reference
	 Manual</citetitle></olink>.)
       In this case, you must also give
       <replaceable>firstparam</replaceable> so
       <command>ptcomp</command> knows where to begin
       counting.</simpara>
      <simpara>It is possible to map several characters to the same
       glyph.  If your font has glyphs only for lower-case letters,
       you could map the upper-case letters to them too.  But
       <application>DUMB</application> will do this automatically, so
       don't bother.</simpara>
     </listitem>
    </varlistentry>
    <varlistentry>
     <term>
      <indexterm id="keyword-descent" role="keyword">
       <primary>Descent</primary>
      </indexterm>
<synopsis>
Descent <replaceable>charid:integer</replaceable> <replaceable>descent:integer</replaceable>
</synopsis>
     </term>
     <listitem>
      <simpara>Defines the height at which the glyph of
      <replaceable>charid</replaceable> should be drawn.  The default
       is <replaceable>descent</replaceable>=0, meaning the bottom of
       the glyph will be at the baseline.  If
       <replaceable>descent</replaceable> is positive, the bottom of
       the glyph will hang that many pixels below the baseline.
       Negative values raise the glyph above the baseline.</simpara>
      <simpara><replaceable>charid</replaceable> must already have
       been bound to a glyph with
       <token lang=".pt" role="keyword">CodingRange</token>.</simpara>
     </listitem>
    </varlistentry>
   </variablelist>
   <sect1 id="sect-fontmapping">
    <title>FontMapping</title>
    <indexterm id="concept-font-map" role="concept">
     <primary>font map</primary>
    </indexterm>
    <simpara><application>DUMB</application> itself does not refer to
     fonts by name.  Instead, each place where a font is used has a
     numeric ID, and the WAD must contain a font map saying which font
     to use for each ID.  The font map is kept in the
     <database role="lumpname">FONTMAP</database> lump.</simpara>
    <simpara>To define font mappings, use the
     <token lang=".pt" role="keyword">FontMapping</token>
     clause:</simpara>
    <variablelist>
     <varlistentry>
      <term>
       <indexterm id="keyword-fontmapping" role="keyword">
	<primary>FontMapping</primary>
       </indexterm>
<synopsis>
FontMapping <replaceable>id:integer</replaceable> <replaceable>fontname:string8</replaceable>
</synopsis>
      </term>
      <listitem>
       <simpara>Map the usage <replaceable>id</replaceable> to font
	<replaceable>fontname</replaceable>.</simpara>
       <simpara>If you don't specify font mappings for some ids, then
	those places can't be drawn in the usual way.
	<application>DUMB</application> may have fallback methods for
	some of them; for example, game messages are printed to the
	error log.</simpara>
      </listitem>
     </varlistentry>
    </variablelist>
    <simpara>Here are the constants you can use for
     <replaceable>id</replaceable>.  They are all defined in
     <filename>&lt;dumb/dumbdefs.pt&gt;</filename>.</simpara>
    <variablelist>
     <varlistentry>
      <term>
       <indexterm id="keyword-fontmap-gettablecount" role="keyword">
	<primary>FONTMAP_GETTABLECOUNT</primary>
       </indexterm>
       <token lang=".pt" role="macro">FONTMAP_GETTABLECOUNT</token>
      </term>
      <listitem>
       <simpara>Numbers showing how many units of a gettable the
	player is carrying.</simpara>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>
       <indexterm id="keyword-fontmap-message" role="keyword">
	<primary>FONTMAP_MESSAGE</primary>
       </indexterm>
       <token lang=".pt" role="macro">FONTMAP_MESSAGE</token>
      </term>
      <listitem>
       <simpara>Messages scrolling over the screen.</simpara>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>
       <indexterm id="keyword-fontmap-menu" role="keyword">
	<primary>FONTMAP_MENU</primary>
       </indexterm>
       <token lang=".pt" role="macro">FONTMAP_MENU</token>
      </term>
      <listitem>
       <simpara>Not yet implemented.</simpara>
      </listitem>
     </varlistentry>
    </variablelist>
   </sect1>
  </chapter>
 </part>
 &generated-index;
</book>

<!--
Local Variables:
sgml-indent-step: 1
sgml-custom-markup: (("pt keyword" "<token lang=\".pt\" role=\"keyword\">\r</token>") ("pt constant" "<token lang=\".pt\" role=\"constant\">\r</token>") ("pt clause" "<literal lang=\".pt\" role=\"clause\">\r</literal>") ("level" "<database role=\"level\">\r</database>") ("lumpname" "<database role=\"lumpname\">\r</database>"))
End:
-->